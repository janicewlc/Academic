#Generating Seeds
N <- 1500
n <- 100
seed <- round(runif(n,0,1)*10000, digits = 0)

#Generating Random Numbers
k <- 479
m <- 10000
RN <- rep(1,N)
all.RN <- matrix(nrow = n, ncol = N)

for(ii in 1:n){
  RN[1] = (seed[ii]*k) %% m
  all.RN[ii,1] <- RN[1]/10000
  for(jj in 2:N){
    RN[jj] = (RN[jj-1]*k) %% m
    all.RN[ii,jj] <-RN[jj]/10000
  }
}

#Test for Random Numbers
validated.seed_u1 <- c()
validated.seed_i1 <- c()

###Test for uniformity: K-S Test
all.RNsort <- t(t(apply(all.RN,1,sort)))
RN.kstest <- matrix(nrow = N, ncol = 6)
colnames(RN.kstest) <- c("i", "ui", "(i-1)/n", "i/n", "D-", "D+")

for(i in 1:n){
  for(j in 1:N){
    RN.kstest[j,1] <- j  
    RN.kstest[j,2] <- all.RNsort[j,i]
    RN.kstest[j,3] <- (j-1)/N
    RN.kstest[j,4] <- j/N
    RN.kstest[j,5] <- ((j-1)/N)-RN.kstest[j,2]
    RN.kstest[j,6] <- RN.kstest[j,2]-(j/N)
    }
  if(max(RN.kstest[,5],RN.kstest[,6])<1.36/sqrt(N)){
    print(paste("The random numbers generated by seed = ",seed[i]," are accepted."))
    validated.seed_u1[i]=seed[i]
  }else{
    print(paste("The random numbers generated by seed = ",seed[i]," are not accepted."))
  }
}

###Test for independency: Good's Serial Test
all.RNno <- matrix(nrow = n, ncol = N)
for(i in 1:n){
  for(j in 1:N){
    if(all.RN[i,j]<=0.25){
      all.RNno[i,j] <- 1
    }else{
      if(all.RN[i,j]>0.25 & all.RN[i,j]*10000<=0.5*10000){
        all.RNno[i,j] <- 2
      }else{
        if(all.RN[i,j]*10000>0.5*10000 & all.RN[i,j]*10000<=0.75*10000){
          all.RNno[i,j] <- 3
        }else{
          if(all.RN[i,j]*10000>0.75*10000 & all.RN[i,j]*10000<=1*10000)
            all.RNno[i,j] <-4
        }
      }
    }
  }
}
all.RNnomatix <- matrix(0,nrow = 4, ncol = 4)
for(i in 1:1){
  for(j in 1:N-1){
    all.RNnomatix[all.RNno[i,j],all.RNno[i,j+1]] = all.RNnomatix[all.RNno[i,j],all.RNno[i,j+1]]+1
  }
  sum1 <- 0
  sum2 <- 0
  print(all.RNnomatix)
  for(a in 1:4){
    for(b in 1:4){
      sum1 <- sum1 + (all.RNnomatix[a,b]-(N/(4^2)))^2
    }
    sum2 <- sum2 + (sum(all.RNnomatix[a,])-(N/4))^2
  }
  U <- ((4^2)/N)*sum1-(4/N)*sum2
  if(U<qchisq(1-0.05,4*(4-1))){
    print(paste("U =",U))
    print(paste("The random numbers generated by seed = ",seed[i]," are accepted."))
    validated.seed_i1[i]=seed[i]
  }else{
    print(paste("U =",U))
    print(paste("The random numbers generated by seed = ",seed[i]," are not accepted."))
  }
  all.RNnomatix <- matrix(0,nrow = 4, ncol = 4)
}

#Saving Valid Seeds and Random Numbers
new.seed <- c()

for(ii in 1:n){
  if(is.na(validated.seed_u1[ii])||is.na(validated.seed_i1[ii])){
    new.seed[ii] <- NA
  }else{
    new.seed[ii] <- validated.seed_i1[ii] ###Deleting Rejected Seeds
  }
}
new.seed <- new.seed[!is.na(new.seed)]
all.RN_star <- matrix(nrow = NROW(new.seed), ncol = N)

for(ii in 1:NROW(new.seed)){
  RN[1] = (new.seed[ii]*k) %% m
  all.RN_star[ii,1] <- RN[1]/10000
  for(jj in 2:N){
    RN[jj] = (RN[jj-1]*k) %% m
    all.RN_star[ii,jj] <- RN[jj]/10000
  }
}

#Generate Random Variates	
###RN from Normal Distribution by Polar Method
###1. Spinning
v1 <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
v2 <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
for(iii in 1:(NROW(new.seed)/4)){
  for(iiii in 1:N-1){
    if(iiii%%2 == 0){
      v1[iii,iiii] <- 99
      v2[iii,iiii] <- 99
    }else{
      v1[iii,iiii] <- 2*all.RN_star[iii+3*(iii-1),iiii]-1
      v2[iii,iiii] <- 2*all.RN_star[iii+3*(iii-1),iiii+1]-1
      w <- v1^2 +v2^2
      }
    }
  for (i in 1:N){
    if(w[iii,i] > 1){
    v1[iii,i] <- NA
    v2[iii,i] <- NA
    w[iii,i] <- NA
    }
  }
}

z1 <- v1*sqrt((-2*log(w))/w)
z2 <- v2*sqrt((-2*log(w))/w)

## Spinning ~ N(240,120)
spinning <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
for(i in 1:NROW(new.seed)/4){
  for(j in 1:N){
    if(j%%2!=0){
      spinning[i,j] <- 240 + z1[i,j] * sqrt(120)
    }else{
      spinning[i,j] <- 240 + z2[i,j] * sqrt(120)
    }
  }

###2. Weaving
v1_w <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
v2_w <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
for(iii in 1:(NROW(new.seed)/4)){
  for(iiii in 1:N-1){
    if(iiii%%2 == 0){
      v1_w[iii,iiii] <- 99
      v2_w[iii,iiii] <- 99
    }else{
      v1_w[iii,iiii] <- 2*all.RN_star[iii+3*(iii-1)+1,iiii]-1
      v2_w[iii,iiii] <- 2*all.RN_star[iii+3*(iii-1)+1,iiii+1]-1
      w_w <- v1_w^2 +v2_w^2
    }
  }
  for (i in 1:N){
    if(w_w[iii,i] > 1){
      v1_w[iii,i] <- NA
      v2_w[iii,i] <- NA
      w_w[iii,i] <- NA
    }
  }
}

z1_w <- v1_w*sqrt((-2*log(w_w))/w_w)
z2_w <- v2_w*sqrt((-2*log(w_w))/w_w)
}

## Weaving ~ N(480,200)
weaving <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
for(i in 1:NROW(new.seed)/4){
  for(j in 1:N){
    if(j%%2!=0){
      weaving[i,j] <- 480 + z1_w[i,j] * sqrt(200)
    }else{
      weaving[i,j] <- 480 + z2_w[i,j] * sqrt(200)
    }
  }
}

#Delecting the rejected random numbers and save the accepted ones
spinning_list <- tapply(spinning, rep(1:nrow(spinning), ncol(spinning)), function(i)i)
spinning_star <- lapply(spinning_list, function(x) x[!is.na(x)])
weaving_list <- tapply(weaving, rep(1:nrow(weaving), ncol(weaving)), function(i)i)
weaving_star <- lapply(weaving_list, function(x) x[!is.na(x)])


###RN from Exponential Distribution by Inverse Transformation
## Fininshing F ~ Exp(120)
## f=120e^(-120f), F=-120ln(1-u)
## Packing P ~ Exp(360)
## p=360e^(-360p), P=-360ln(1-u)
finishing <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
packing <- matrix(0, nrow = NROW(new.seed)/4, ncol = N)
for(iii in 1:(NROW(new.seed)/4)){
  finishing[iii,] <- -120 * log(1-all.RN_star[iii+3*(iii-1)+2,])
  packing[iii,] <- -360 * log(1-all.RN_star[iii+3*(iii-1)+3,])
}

finishing_star <- tapply(finishing, rep(1:nrow(finishing), ncol(finishing)), function(i)i)
packing_star <- tapply(packing, rep(1:nrow(packing), ncol(packing)), function(i)i)
